services:
  # This is the Nginx container that acts as a reverse proxy
  nginx:
    container_name: kf_nginx
    image: kartflip/nginx
    build:
      context: ./_containers/nginx
      dockerfile: Dockerfile.nginx
    depends_on:
    - daphne
    volumes:
      - ./_containers/nginx/conf.d:/etc/nginx/conf.d
      - ./app/staticfiles:/app/staticfiles
      - ./app/mediafiles:/app/mediafiles
    ports:
      - "9000:80"
    networks:
      - frontend_network
    restart: on-failure:3

  # This is the Daphne server which serves our Django application using ASGI (async & websockets)
  daphne:
    container_name: kf_daphne
    image: kartflip/daphne
    build:
      context: ./_containers/django
      dockerfile: Dockerfile.django_daphne
    depends_on:
      - postgresql
    volumes:
      - ./app:/app
    env_file:
      - ./_containers/django/.env_django
    networks:
      - frontend_network
      - backend_network
    restart: on-failure:3
    secrets:
      - postgresql_db
      - postgresql_user
      - postgresql_password
      - django_secretkey
      - redis_tasks_password

  # This is our PostgreSQL container that acts as our primary data store aka Database
  postgresql:
    container_name: kf_postgresql
    image: kartflip/postgresql
    build:
      context: ./_containers/postgresql
      dockerfile: Dockerfile.postgresql
    volumes:
      - KF_postgresql_data:/var/lib/postgresql/data
      - ./_containers/postgresql/init_scripts:/docker-entrypoint-initdb.d
    environment:
      POSTGRES_DB_FILE: /run/secrets/postgresql_db
      POSTGRES_USER_FILE: /run/secrets/postgresql_user
      POSTGRES_PASSWORD_FILE: /run/secrets/postgresql_password
    networks:
      - backend_network
    restart: on-failure:3
    secrets:
      - postgresql_db
      - postgresql_user
      - postgresql_password

  # This is the Celery worker & scheduler container for handling tasks
  celery_tasks:
    container_name: kf_celery_tasks
    image: kartflip/celery_tasks
    build:
      context: ./_containers/tasks
      dockerfile: Dockerfile.celery_tasks
    depends_on:
      - postgresql
      - redis_tasks
    volumes:
      - ./app:/app
    env_file:
      - ./_containers/django/.env_django
      - ./_containers/tasks/.env_redis_tasks
    networks:
      - backend_network
      - tasks_network
    restart: on-failure:3
    secrets:
      - postgresql_db
      - postgresql_user
      - postgresql_password
      - django_secretkey
      - redis_tasks_password

  # This is our Redis container that acts as a message broker for Celery tasks
  redis_tasks:
    container_name: kf_redis_tasks
    image: kartflip/redis_tasks
    build:
      context: ./_containers/tasks
      dockerfile: Dockerfile.redis_tasks
    volumes:
      - KF_redis_tasks_data:/data
    networks:
      - tasks_network
    restart: on-failure:3
    secrets:
      - redis_tasks_password

volumes:
  KF_postgresql_data:
    external: true
  KF_redis_tasks_data:
    external: true

networks:
  frontend_network:
    driver: bridge
  backend_network:
    driver: bridge
  tasks_network:
    driver: bridge

secrets:
  postgresql_db:
    file: ./_secrets/postgresql_db_v1.txt
  postgresql_user:
    file: ./_secrets/postgresql_user_v1.txt
  postgresql_password:
    file: ./_secrets/postgresql_password_v1.txt
  django_secretkey:
    file: ./_secrets/django_secretkey_v1.txt
  redis_tasks_password:
    file: ./_secrets/redis_tasks_password_v1.txt


